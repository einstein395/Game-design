<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Maze</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: #05050f;
            background-image:
                radial-gradient(circle at 20% 30%, rgba(255, 0, 100, 0.06) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0, 200, 255, 0.06) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(120, 0, 255, 0.04) 0%, transparent 60%);
            font-family: 'Orbitron', 'Segoe UI', sans-serif;
            color: #e0e0e0;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            font-weight: 900;
            color: #ff0066;
            text-shadow:
                0 0 10px #ff0066,
                0 0 30px rgba(255, 0, 102, 0.5),
                0 0 60px rgba(255, 0, 102, 0.2);
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .instructions {
            margin-bottom: 25px;
            font-size: 0.8rem;
            color: #0cf;
            text-shadow: 0 0 8px rgba(0, 200, 255, 0.5);
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .maze-border {
            padding: 6px;
            background: #0a0a1a;
            border: 2px solid #0cf;
            border-radius: 4px;
            box-shadow:
                0 0 15px rgba(0, 200, 255, 0.3),
                0 0 40px rgba(0, 200, 255, 0.1),
                inset 0 0 15px rgba(0, 200, 255, 0.1);
            position: relative;
        }

        .maze-border::before {
            content: '';
            position: absolute;
            inset: -4px;
            border: 1px solid rgba(255, 0, 102, 0.3);
            border-radius: 6px;
            pointer-events: none;
        }

        .maze-border::after {
            content: '';
            position: absolute;
            inset: -8px;
            border: 1px solid rgba(120, 0, 255, 0.15);
            border-radius: 8px;
            pointer-events: none;
        }

        .grid {
            display: grid;
            gap: 2px;
            padding: 0;
            overflow: hidden;
            position: relative;
            z-index: 1;
            background: #0a0a1a;
        }

        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: relative;
        }

        /* Neon walls — dark blocks with glowing edges */
        .cell.wall {
            background: #0c0c18;
            border: 1px solid #1a1a30;
            box-shadow:
                inset 0 0 8px rgba(0, 0, 0, 0.8);
        }

        .cell.wall::before {
            content: '';
            position: absolute;
            inset: 2px;
            border: 1px solid rgba(120, 0, 255, 0.08);
            pointer-events: none;
        }

        /* Path — indistinguishable from walls */
        .cell.path {
            background: #0e0e1c;
            border: 1px solid #1a1a30;
            box-shadow:
                inset 0 0 8px rgba(0, 0, 0, 0.7);
        }

        .cell.path::before {
            content: '';
            position: absolute;
            inset: 2px;
            border: 1px solid rgba(120, 0, 255, 0.06);
            pointer-events: none;
        }

        /* Player cell */
        .cell.player {
            background: #0e0e1c;
            border: 1px solid #1a1a30;
            box-shadow:
                inset 0 0 8px rgba(0, 0, 0, 0.7);
            z-index: 2;
        }

        .cell.player .person {
            filter: drop-shadow(0 0 6px rgba(0, 200, 255, 0.8));
            position: relative;
            z-index: 3;
        }

        /* Start tile */
        .cell.start {
            background: #0e0e1c;
            border: 1px solid #1a1a30;
            box-shadow:
                inset 0 0 8px rgba(0, 0, 0, 0.7);
        }

        /* End tile */
        .cell.end {
            background: #0e0e1c;
            border: 1px solid #1a1a30;
            box-shadow:
                inset 0 0 8px rgba(0, 0, 0, 0.7);
        }

        /* Revealed wall — neon magenta cube */
        .cell.wall-revealed {
            background: #12081a;
            border: 1px solid #ff0066;
            box-shadow:
                inset 0 0 12px rgba(255, 0, 102, 0.2),
                0 0 8px rgba(255, 0, 102, 0.4),
                0 0 20px rgba(255, 0, 102, 0.15);
            animation: neonReveal 0.3s ease-out;
        }

        .cell.wall-revealed::before {
            content: '';
            position: absolute;
            inset: 3px;
            border: 1px solid rgba(255, 0, 102, 0.3);
            pointer-events: none;
        }

        .cell.wall-revealed::after {
            content: '';
            position: absolute;
            inset: 6px;
            border: 1px solid rgba(255, 0, 102, 0.15);
            pointer-events: none;
        }

        @keyframes neonReveal {
            0% {
                transform: scale(0.8);
                opacity: 0;
                box-shadow: 0 0 30px rgba(255, 0, 102, 0.8);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 20px rgba(255, 0, 102, 0.6);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Obstacle — electric trap */
        .cell.obstacle {
            background: #0e0e1c;
            border: 1px solid rgba(255, 200, 0, 0.3);
            box-shadow:
                inset 0 0 10px rgba(255, 200, 0, 0.08);
        }

        .cell.obstacle::before {
            content: '';
            position: absolute;
            inset: 2px;
            border: 1px solid rgba(255, 200, 0, 0.15);
            pointer-events: none;
        }

        .cell.obstacle::after {
            content: '\u26A1';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: inherit;
            opacity: 0.7;
            animation: sparkle 1s ease-in-out infinite alternate;
            pointer-events: none;
        }

        @keyframes sparkle {
            from {
                opacity: 0.4;
                text-shadow: 0 0 4px rgba(255, 200, 0, 0.3);
            }
            to {
                opacity: 0.9;
                text-shadow: 0 0 10px rgba(255, 200, 0, 0.7), 0 0 20px rgba(255, 200, 0, 0.3);
            }
        }

        /* Visited path — cyan neon trail */
        .cell.visited {
            background: #0a0c1a;
            border: 1px solid rgba(0, 200, 255, 0.25);
            box-shadow:
                inset 0 0 10px rgba(0, 200, 255, 0.08);
        }

        .cell.visited::before {
            content: '';
            position: absolute;
            inset: 2px;
            border: 1px solid rgba(0, 200, 255, 0.1);
            pointer-events: none;
        }

        .cell.visited::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: #0cf;
            border-radius: 50%;
            box-shadow:
                0 0 6px #0cf,
                0 0 12px rgba(0, 200, 255, 0.4);
            pointer-events: none;
        }

        #message {
            margin-top: 30px;
            font-size: 1.1rem;
            min-height: 2rem;
            color: #0cf;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 200, 255, 0.5);
            letter-spacing: 2px;
        }

        #timer {
            margin-top: 15px;
            font-size: 1.5rem;
            font-weight: 700;
            color: #0cf;
            text-shadow:
                0 0 8px rgba(0, 200, 255, 0.5),
                0 0 20px rgba(0, 200, 255, 0.2);
            font-variant-numeric: tabular-nums;
            letter-spacing: 3px;
        }

        #timer.warning {
            color: #ff0066;
            text-shadow:
                0 0 8px rgba(255, 0, 102, 0.6),
                0 0 20px rgba(255, 0, 102, 0.3);
            animation: neonPulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes neonPulse {
            from {
                opacity: 1;
                text-shadow: 0 0 8px rgba(255, 0, 102, 0.6), 0 0 20px rgba(255, 0, 102, 0.3);
            }
            to {
                opacity: 0.6;
                text-shadow: 0 0 4px rgba(255, 0, 102, 0.3);
            }
        }

        @keyframes pulse {
            from { opacity: 1; }
            to { opacity: 0.6; }
        }

        #nextLevel {
            display: none;
            margin-top: 15px;
            padding: 12px 30px;
            font-size: 0.9rem;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            background: transparent;
            color: #0cf;
            border: 2px solid #0cf;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 8px rgba(0, 200, 255, 0.5);
            box-shadow:
                0 0 10px rgba(0, 200, 255, 0.2),
                inset 0 0 10px rgba(0, 200, 255, 0.05);
        }

        #nextLevel:hover {
            background: rgba(0, 200, 255, 0.1);
            box-shadow:
                0 0 20px rgba(0, 200, 255, 0.4),
                inset 0 0 15px rgba(0, 200, 255, 0.1);
        }
    </style>
</head>
<body>
    <h1 id="title">Maze — Level 1</h1>
    <p class="instructions">Use arrow keys to navigate from start to finish</p>
    <p id="timer">Time: 30s</p>
    <div class="maze-border">
        <div class="grid" id="grid"></div>
    </div>
    <p id="message"></p>
    <button id="nextLevel" onclick="startLevel(2)">Next Level</button>

    <script>
        // Level 1: 3x3 with more walls (4 walls)
        const level1Maze = [
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0]
        ];

        let currentLevel = 1;
        let logicalMaze = [];
        let visualGrid = [];
        let logicalRows = 3;
        let logicalCols = 3;
        let visualRows = 0;
        let visualCols = 0;
        let start = { row: 0, col: 0 };
        let end = { row: 0, col: 0 };
        let player = { row: 0, col: 0 };
        let visited = new Set();
        let revealedWalls = new Set();
        let won = false;
        let timeLeft = 30;
        let timerInterval = null;

        function hasPath(grid, sr, sc, er, ec) {
            const r = grid.length;
            const c = grid[0].length;
            const visited = Array.from({ length: r }, () => Array(c).fill(false));
            const queue = [[sr, sc]];
            visited[sr][sc] = true;
            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            while (queue.length > 0) {
                const [cr, cc] = queue.shift();
                if (cr === er && cc === ec) return true;
                for (const [dr, dc] of dirs) {
                    const nr = cr + dr;
                    const nc = cc + dc;
                    if (nr >= 0 && nr < r && nc >= 0 && nc < c && !visited[nr][nc] && grid[nr][nc] !== 1) {
                        visited[nr][nc] = true;
                        queue.push([nr, nc]);
                    }
                }
            }
            return false;
        }

        // Find a path using BFS and return it as array of [r,c], or null
        function findPath(grid, sr, sc, er, ec) {
            const r = grid.length;
            const c = grid[0].length;
            const visited = Array.from({ length: r }, () => Array(c).fill(false));
            const parent = Array.from({ length: r }, () => Array(c).fill(null));
            const queue = [[sr, sc]];
            visited[sr][sc] = true;
            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            while (queue.length > 0) {
                const [cr, cc] = queue.shift();
                if (cr === er && cc === ec) {
                    const path = [];
                    let cur = [er, ec];
                    while (cur) {
                        path.unshift(cur);
                        cur = parent[cur[0]][cur[1]];
                    }
                    return path;
                }
                for (const [dr, dc] of dirs) {
                    const nr = cr + dr;
                    const nc = cc + dc;
                    if (nr >= 0 && nr < r && nc >= 0 && nc < c && !visited[nr][nc] && grid[nr][nc] !== 1) {
                        visited[nr][nc] = true;
                        parent[nr][nc] = [cr, cc];
                        queue.push([nr, nc]);
                    }
                }
            }
            return null;
        }

        // Check that at least 2 distinct paths exist
        function hasAlternatePath(grid, sr, sc, er, ec) {
            const path = findPath(grid, sr, sc, er, ec);
            if (!path || path.length < 3) return false;
            // Block each intermediate cell on the path and check if another route exists
            for (let i = 1; i < path.length - 1; i++) {
                const [br, bc] = path[i];
                const saved = grid[br][bc];
                grid[br][bc] = 1;
                const alt = hasPath(grid, sr, sc, er, ec);
                grid[br][bc] = saved;
                if (alt) return true;
            }
            return false;
        }

        function generateLevel2Maze() {
            const size = 6;
            let grid;
            const wallCount = 16;
            do {
                grid = Array.from({ length: size }, () => Array(size).fill(0));
                let placed = 0;
                while (placed < wallCount) {
                    const r = Math.floor(Math.random() * size);
                    const c = Math.floor(Math.random() * size);
                    if ((r === 0 && c === 0) || (r === size - 1 && c === size - 1)) continue;
                    if (grid[r][c] === 1) continue;
                    grid[r][c] = 1;
                    placed++;
                }
            } while (!hasAlternatePath(grid, 0, 0, size - 1, size - 1));
            return grid;
        }

        // Level 3: 9x9 maze with obstacles (value 2)
        function generateLevel3Maze() {
            const size = 9;
            let grid;
            const wallCount = 38; // ~47% walls — very dense
            const obstacleCount = 5;
            do {
                grid = Array.from({ length: size }, () => Array(size).fill(0));
                let placed = 0;
                while (placed < wallCount) {
                    const r = Math.floor(Math.random() * size);
                    const c = Math.floor(Math.random() * size);
                    if ((r === 0 && c === 0) || (r === size - 1 && c === size - 1)) continue;
                    if (grid[r][c] !== 0) continue;
                    grid[r][c] = 1;
                    placed++;
                }
                // Place obstacles on open path cells (not start/end)
                let obs = 0;
                let attempts = 0;
                while (obs < obstacleCount && attempts < 200) {
                    const r = Math.floor(Math.random() * size);
                    const c = Math.floor(Math.random() * size);
                    attempts++;
                    if ((r === 0 && c === 0) || (r === size - 1 && c === size - 1)) continue;
                    if (grid[r][c] !== 0) continue;
                    // Don't place on cells adjacent to start
                    if (r <= 1 && c <= 1) continue;
                    grid[r][c] = 2; // obstacle
                    obs++;
                }
            } while (!hasAlternatePath(grid, 0, 0, size - 1, size - 1));
            return grid;
        }

        function expandToWallGrid(logical) {
            const lr = logical.length;
            const lc = logical[0].length;
            const vr = lr * 2 + 1;
            const vc = lc * 2 + 1;
            const grid = Array.from({ length: vr }, () => Array(vc).fill(1));

            // Carve open cells and place obstacles
            for (let r = 0; r < lr; r++) {
                for (let c = 0; c < lc; c++) {
                    if (logical[r][c] === 0) {
                        grid[r * 2 + 1][c * 2 + 1] = 0;
                    } else if (logical[r][c] === 2) {
                        grid[r * 2 + 1][c * 2 + 1] = 2; // obstacle
                    }
                }
            }

            // Carve connections (obstacles count as open for connections)
            for (let r = 0; r < lr; r++) {
                for (let c = 0; c < lc; c++) {
                    if (logical[r][c] === 1) continue; // skip walls
                    if (c + 1 < lc && logical[r][c + 1] !== 1) {
                        grid[r * 2 + 1][c * 2 + 2] = 0;
                    }
                    if (r + 1 < lr && logical[r + 1][c] !== 1) {
                        grid[r * 2 + 2][c * 2 + 1] = 0;
                    }
                }
            }

            return grid;
        }

        function createPersonSVG(size) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 100 100');
            svg.setAttribute('width', size);
            svg.setAttribute('height', size);
            svg.classList.add('person');

            svg.innerHTML = `
                <!-- Neon glow under player -->
                <ellipse cx="50" cy="92" rx="18" ry="5" fill="rgba(0,204,255,0.3)"/>
                <!-- Legs — dark with cyan trim -->
                <rect x="39" y="60" width="9" height="24" rx="4" fill="#1a1a30"/>
                <rect x="39" y="60" width="9" height="24" rx="4" fill="none" stroke="#0cf" stroke-width="0.5" opacity="0.4"/>
                <rect x="52" y="60" width="9" height="24" rx="4" fill="#1a1a30"/>
                <rect x="52" y="60" width="9" height="24" rx="4" fill="none" stroke="#0cf" stroke-width="0.5" opacity="0.4"/>
                <!-- Boots -->
                <ellipse cx="43" cy="86" rx="7" ry="4" fill="#0a0a18" stroke="#ff0066" stroke-width="0.5" opacity="0.8"/>
                <ellipse cx="57" cy="86" rx="7" ry="4" fill="#0a0a18" stroke="#ff0066" stroke-width="0.5" opacity="0.8"/>
                <!-- Body — dark jacket -->
                <rect x="36" y="32" width="28" height="30" rx="6" fill="#12122a"/>
                <rect x="36" y="32" width="28" height="30" rx="6" fill="none" stroke="#0cf" stroke-width="1" opacity="0.5"/>
                <!-- Neon stripe on jacket -->
                <line x1="50" y1="34" x2="50" y2="60" stroke="#ff0066" stroke-width="1.5" opacity="0.6"/>
                <!-- Arms -->
                <rect x="22" y="34" width="15" height="9" rx="4.5" fill="#12122a" stroke="#0cf" stroke-width="0.5" opacity="0.8"/>
                <rect x="63" y="34" width="15" height="9" rx="4.5" fill="#12122a" stroke="#0cf" stroke-width="0.5" opacity="0.8"/>
                <!-- Neck -->
                <rect x="45" y="28" width="10" height="8" rx="3" fill="#d4a878"/>
                <!-- Head -->
                <circle cx="50" cy="20" r="14" fill="#d4a878"/>
                <!-- Cyber hair -->
                <ellipse cx="50" cy="13" rx="13" ry="9" fill="#1a0a2a"/>
                <ellipse cx="50" cy="13" rx="13" ry="9" fill="none" stroke="#ff0066" stroke-width="0.5" opacity="0.4"/>
                <!-- Cyber visor/eyes -->
                <rect x="40" y="18" rx="2" width="20" height="5" fill="#0a0a18" opacity="0.8"/>
                <rect x="41" y="19" rx="1" width="8" height="3" fill="#0cf" opacity="0.9"/>
                <rect x="51" y="19" rx="1" width="8" height="3" fill="#0cf" opacity="0.9"/>
                <!-- Mouth -->
                <line x1="45" y1="28" x2="55" y2="28" stroke="#0cf" stroke-width="0.5" opacity="0.3"/>
            `;

            return svg;
        }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timeLeft = 30;
            const timerEl = document.getElementById('timer');
            timerEl.textContent = 'Time: 30s';
            timerEl.classList.remove('warning');

            timerInterval = setInterval(() => {
                if (won) {
                    clearInterval(timerInterval);
                    return;
                }
                timeLeft--;
                timerEl.textContent = 'Time: ' + timeLeft + 's';

                if (timeLeft <= 10) {
                    timerEl.classList.add('warning');
                }

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    won = true;
                    if (currentLevel === 3) {
                        document.getElementById('message').textContent = 'Time\'s up! Back to Level 1.';
                        document.getElementById('message').style.color = '#ff4444';
                        document.getElementById('nextLevel').textContent = 'Restart';
                        document.getElementById('nextLevel').style.display = 'inline-block';
                        document.getElementById('nextLevel').onclick = function() { startLevel(1); };
                    } else {
                        document.getElementById('message').textContent = 'Time\'s up! Try again.';
                        document.getElementById('message').style.color = '#ff4444';
                        document.getElementById('nextLevel').textContent = 'Retry';
                        document.getElementById('nextLevel').style.display = 'inline-block';
                        document.getElementById('nextLevel').onclick = function() { startLevel(currentLevel); };
                    }
                }
            }, 1000);
        }

        function startLevel(level) {
            currentLevel = level;
            won = false;
            document.getElementById('message').textContent = '';
            document.getElementById('message').style.color = '#f0f0f0';
            document.getElementById('nextLevel').style.display = 'none';
            document.getElementById('nextLevel').textContent = 'Next Level';
            document.getElementById('nextLevel').onclick = function() { startLevel(2); };
            document.getElementById('title').textContent = 'Maze \u2014 Level ' + level;

            if (level === 1) {
                logicalMaze = level1Maze.map(row => [...row]);
                logicalRows = 3;
                logicalCols = 3;
            } else if (level === 2) {
                logicalMaze = generateLevel2Maze();
                logicalRows = 6;
                logicalCols = 6;
            } else {
                logicalMaze = generateLevel3Maze();
                logicalRows = 9;
                logicalCols = 9;
            }

            visualGrid = expandToWallGrid(logicalMaze);
            visualRows = visualGrid.length;
            visualCols = visualGrid[0].length;

            start = { row: 1, col: 1 };
            end = { row: visualRows - 2, col: visualCols - 2 };
            player = { row: start.row, col: start.col };
            visited = new Set();
            revealedWalls = new Set();
            visited.add(start.row + ',' + start.col);

            const gridEl = document.getElementById('grid');
            const cellSize = level === 1 ? 60 : level === 2 ? 38 : 28;
            gridEl.style.gridTemplateColumns = 'repeat(' + visualCols + ', ' + cellSize + 'px)';
            gridEl.style.gridTemplateRows = 'repeat(' + visualRows + ', ' + cellSize + 'px)';

            render();
            startTimer();
        }

        function render() {
            const gridEl = document.getElementById('grid');
            gridEl.innerHTML = '';
            const iconSize = currentLevel === 1 ? 44 : currentLevel === 2 ? 28 : 20;
            const markerSize = currentLevel === 1 ? '1.2rem' : currentLevel === 2 ? '0.75rem' : '0.5rem';

            for (let r = 0; r < visualRows; r++) {
                for (let c = 0; c < visualCols; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');

                    if (player.row === r && player.col === c) {
                        cell.classList.add('player');
                        cell.appendChild(createPersonSVG(iconSize));
                    } else if (r === start.row && c === start.col) {
                        cell.classList.add('start');
                        cell.style.fontSize = markerSize;
                        cell.style.color = '#0cf';
                        cell.style.textShadow = '0 0 8px rgba(0,204,255,0.6)';
                        cell.style.zIndex = '1';
                        cell.textContent = 'START';
                    } else if (r === end.row && c === end.col) {
                        cell.classList.add('end');
                        cell.style.fontSize = markerSize;
                        cell.style.color = '#ff0066';
                        cell.style.textShadow = '0 0 8px rgba(255,0,102,0.6)';
                        cell.style.zIndex = '1';
                        cell.textContent = 'EXIT';
                    } else if (visualGrid[r][c] === 1 && revealedWalls.has(r + ',' + c)) {
                        cell.classList.add('wall-revealed');
                    } else if (visualGrid[r][c] === 1) {
                        cell.classList.add('wall');
                    } else if (visualGrid[r][c] === 2) {
                        cell.classList.add('obstacle');
                        cell.style.fontSize = currentLevel === 3 ? '0.7rem' : '1rem';
                    } else if (visited.has(r + ',' + c)) {
                        cell.classList.add('visited');
                    } else {
                        cell.classList.add('path');
                    }

                    gridEl.appendChild(cell);
                }
            }
        }

        document.addEventListener('keydown', (e) => {
            if (won) return;

            let newRow = player.row;
            let newCol = player.col;

            switch (e.key) {
                case 'ArrowUp':    newRow--; break;
                case 'ArrowDown':  newRow++; break;
                case 'ArrowLeft':  newCol--; break;
                case 'ArrowRight': newCol++; break;
                default: return;
            }

            e.preventDefault();

            if (newRow < 0 || newRow >= visualRows || newCol < 0 || newCol >= visualCols) {
                render();
                return;
            }
            if (visualGrid[newRow][newCol] === 1) {
                revealedWalls.add(newRow + ',' + newCol);
                render();
                return;
            }

            player.row = newRow;
            player.col = newCol;
            visited.add(newRow + ',' + newCol);

            // Check if player stepped on an obstacle (electric trap)
            if (visualGrid[newRow][newCol] === 2) {
                // Teleport back to start, clear trail
                player.row = start.row;
                player.col = start.col;
                visited = new Set();
                visited.add(start.row + ',' + start.col);
                document.getElementById('message').textContent = 'ZAP! Teleported back to start!';
                document.getElementById('message').style.color = '#ffc800';
                setTimeout(() => {
                    if (!won) {
                        document.getElementById('message').textContent = '';
                        document.getElementById('message').style.color = '#e0e0e0';
                    }
                }, 1500);
            }

            render();

            if (player.row === end.row && player.col === end.col) {
                won = true;
                clearInterval(timerInterval);
                if (currentLevel === 1) {
                    document.getElementById('message').textContent = 'Level 1 complete! (' + (30 - timeLeft) + 's)';
                    document.getElementById('nextLevel').style.display = 'inline-block';
                    document.getElementById('nextLevel').textContent = 'Next Level';
                    document.getElementById('nextLevel').onclick = function() { startLevel(2); };
                } else if (currentLevel === 2) {
                    document.getElementById('message').textContent = 'Level 2 complete! (' + (30 - timeLeft) + 's)';
                    document.getElementById('nextLevel').style.display = 'inline-block';
                    document.getElementById('nextLevel').textContent = 'Next Level';
                    document.getElementById('nextLevel').onclick = function() { startLevel(3); };
                } else {
                    document.getElementById('message').textContent = 'You win! All levels complete! (' + (30 - timeLeft) + 's)';
                }
            }
        });

        startLevel(1);
    </script>
</body>
</html>
